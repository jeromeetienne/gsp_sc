"""
Check the output files against expected files.
This is part of the testing suite.

It checks that the output files generated by the examples match the expected output files.
"""

# stdlib imports
import sys
import os
import json
import colorama

# pip imports
import skimage.io
import numpy as np
import argparse

__dirname__ = os.path.dirname(os.path.abspath(__file__))
examples_folder = os.path.abspath(os.path.join(__dirname__, "..", "examples"))
expected_folder = os.path.abspath(os.path.join(__dirname__, "..", "examples", "expected"))
output_folder = os.path.abspath(os.path.join(__dirname__, "..", "examples", "output"))


# =============================================================================
# Colorama alias
# =============================================================================
def text_cyan(text: str) -> str:
    return colorama.Fore.CYAN + text + colorama.Style.RESET_ALL


def text_green(text: str) -> str:
    return colorama.Fore.GREEN + text + colorama.Style.RESET_ALL


def text_red(text: str) -> str:
    return colorama.Fore.RED + text + colorama.Style.RESET_ALL


# =============================================================================
# Comparison function
# =============================================================================
def json_deep_comp(obj_1: object, obj_2: object) -> bool:
    """
    Deep comparison of two json objects.
    a json object is a python object typically issued from `json.load` or `json.loads`.

    Arguments:
        o1: First object to compare.
        o2: Second object to compare.

    Returns:
        True if the objects are deeply equal, False otherwise.
    """

    def json_reordered(obj: object) -> object:
        if isinstance(obj, dict):
            return sorted((k, json_reordered(v)) for k, v in obj.items())
        if isinstance(obj, list):
            return sorted(json_reordered(x) for x in obj)  # type: ignore
        else:
            return obj

    obj_1 = json_reordered(obj_1)
    obj_2 = json_reordered(obj_2)
    return obj_1 == obj_2


def verify_file_content(expected_path: str, output_path: str) -> bool:
    """
    Verifies that the content of the output file matches the expected file.

    Arguments:
        expected_path: Path to the expected output file.
        output_path: Path to the actual output file.

    Returns:
        True if the contents match, False otherwise.
    """

    # Read expected content
    with open(expected_path, "rb") as file_reader:
        expected_content = file_reader.read()

    # Read output content
    with open(output_path, "rb") as file_reader:
        output_content = file_reader.read()

    # Compare content based on file type
    file_ext = os.path.splitext(expected_path)[1].lower()
    if file_ext in [".png", ".jpg", ".jpeg"]:
        # Compare images files

        # Read images as np.ndarray using skimage
        expected_image: np.ndarray = skimage.io.imread(expected_path)
        output_image: np.ndarray = skimage.io.imread(output_path)

        # structural similarity index to compare images perceptually - score between -1.0 and 1.0
        score: float = skimage.metrics.structural_similarity(expected_image, output_image, channel_axis=-1)  # type: ignore

        # tolerance threshold - 1.0 is exact match
        # Make this number less than 1.0 to allow for minor differences due to compression, etc.
        tolerance_threshold = 0.99
        content_match = score >= tolerance_threshold
    elif file_ext in [".json"]:
        # Compare json files
        expected_json = json.loads(expected_content)
        output_json = json.loads(output_content)
        content_match = json_deep_comp(expected_json, output_json)
    else:
        # default method: byte by byte comparison
        content_match = expected_content == output_content

    return content_match


###############################################################################
# Main script logic
#


def main() -> None:

    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Check the output files against expected files.")
    args = parser.parse_args()

    # get all basename of files in output directory
    expected_basenames = [basename for basename in os.listdir(expected_folder)]

    # remove all but .png and .json files from the list
    expected_basenames = [basename for basename in expected_basenames if basename.endswith(".png") or basename.endswith(".json")]

    project_rootpath = os.path.abspath(os.path.join(__dirname__, ".."))
    expected_folder_relpath = os.path.relpath(expected_folder, start=project_rootpath)
    output_folder_relpath = os.path.relpath(output_folder, start=project_rootpath)
    print(
        f"Checking {text_cyan(str(len(expected_basenames)))} files in {text_cyan(output_folder_relpath)} against expected files in {text_cyan(expected_folder_relpath)}"
    )

    for basename_file in expected_basenames:

        expected_path = os.path.join(expected_folder, basename_file)
        output_path = os.path.join(output_folder, basename_file)

        expected_relpath = os.path.relpath(expected_path, start=project_rootpath)
        output_relpath = os.path.relpath(output_path, start=project_rootpath)

        # display the basename of the file without new line, and flush the output
        print(f"Checking {text_cyan(expected_relpath)} ... ", end="", flush=True)

        # check if the file exists in the output folder
        if not os.path.exists(output_path):
            print(f"{text_red('FAILED')}")
            print(f"File {text_cyan(basename_file)} does not exist in output folder. output_path {text_cyan(output_relpath)}")
            sys.exit(1)

        # verify the content of the file
        matching_content = verify_file_content(expected_path, output_path)

        # Display result
        if matching_content:
            print(f"{text_green('OK')}")
        else:
            print(f"{text_red('FAILED')}")
            print(f"File {text_cyan(basename_file)} does not match expected output. output_path {text_cyan(output_relpath)}")
            sys.exit(1)

    print(f"All {text_cyan(str(len(expected_basenames)))} files matched successfully. {text_green('OK')}")


if __name__ == "__main__":
    main()
